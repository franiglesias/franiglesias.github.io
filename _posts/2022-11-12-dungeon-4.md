---
layout: post
title: Dungeon 4
categories: articles
tags: python good-practices
---

Aprovecharé esta entrada para hablar de refactor preparatorio, pero también de historias de usuario.

## Historia de usuario: queremos poder jugar

Ahora que ya tenemos una versión _demo_ decente, el siguiente paso es poder interactuar con el juego. Es decir, que la jugadora pueda introducir comandos. La historia de usuario podría redactarse algo así como:

```text
Quiero poder controlar mi personaje para salir de la mazmorra y ganar el juego.
```

Es decir. La historia de usuario define de una manera simple qué es lo siguiente que nuestro cliente quiere que se implemente. Pero necesitamos hablar acerca de qué significa eso. En ese sentido, se dice que la historia de usuario es algo que tiene que caber en una tarjeta de papel e iniciar una conversación.

En esa conversación pueden salir cosas como estas:

* Tiene que haber una forma de que el juego pida los comandos en la consola
* Igual deberíamos dar opción a usar sinónimos
* Qué tal dar una lista de opciones de comandos, para que sea más fácil
* Tiene que valer igual si escribe en mayúsculas o minúsculas
* Imagina que envías los comandos por Telegram, o Whatsapp, o Twitter
* Tiene que haber un prompt, que te diga que escribas algo

Y la cuestión es que tenemos que definir qué es lo mínimo que aportará valor. El valor tiene que venir definido en el enunciado de la historia de usuario:

* Ganar el juego

Para poder ganar el juego, tengo que poder controlar mi personaje o avatar en el mismo.

Para poder controlarlo necesito poder pasarle instrucciones.

Lo mínimo que necesito para eso es que el juego me pida un input y lo use como comando. Ni más ni menos. Esta será mi primera rebanada.

La segunda rebanada sería el _prompt_. Una vez que somos capaces de obtener comandos por medio de la consola, la usabilidad mejorará si el propio juego me indica que tengo que introducir un nuevo comando.

La tercera rebanada sería la de aceptar mayúsculas y minúsculas. De este modo, reduciremos errores simples que perjudiquen la experiencia de juego. En resumen, sanearemos y normalizaremos el input para que la jugadora no tenga que fijarse cn cómo teclear.

Una cuarta rebanada podría ser aceptar sinónimos para algunos comandos. Pero esto ya entra en la categoría de _Nice to Have_, es decir, tenerlo mejora la experiencia de juego, pero no es fundamental. De hecho, estamos intentando avanzar mucho en la planificación y podría ocurrir que, en la práctica, nuestra jugadora no esté interesada en esta prestación.

Por lo tanto, vamos a parar aquí.

– Sin problema. Me lo anoto en el _backlog_ y ya se hará.

Pues no vamos a tener _backlog_. ¿Por qué? Si una idea es lo bastante buena o necesaria, volverá en algún momento, cuando realmente sea necesaria. Tener un _backlog_ de ideas puede ser como llevar una mochila llena de "por si acasos".

En cada entrega lo que haremos es comparar en dónde estamos con dónde querría la jugadora estar. Eso es todo.

## Refactor preparatorio

El estado del proyecto en cada momento es provisional. En el momento que hacemos una entrega y empezamos a considerar el siguiente paso, el código se convierte en obsoleto. No en el sentido de que no sirva, sino de que ya no refleja nuestra idea de lo que es el negocio o dominio en el que trabajamos.

Si abordamos el código de esta manera tenemos que entender que es necesario prepararlo para los cambios. Por ejemplo, ahora que queremos añadir la capacidad de introducir comandos desde la consola, tenemos que preguntarnos si nuestro código está en condiciones de asimilar ese cambio.

Muchas veces no lo estará. Y para ponerlo a punto lo mejor es aplicar técnicas de refactoring, exactamente el tipo de técnicas que usaríamos para tratar un código _legacy_. Porque, de hecho, lo es.

En nuestro proyecto, el entry point `dungeon/__main__.py` instancia y ejecuta `Game` directamente, así que para obtener el input de la jugadora tendríamos que poner código ahí. Esto funciona, pero tiene muy mala pinta, ¿verdad?

```python
import sys

from dungeon.game import Game


def main(args=None):
    if args is None:
        args = sys.argv[1:]

    print("Welcome to the Dungeon")
    print("-")
    game = Game()
    game.start()
    finished = False
    while not finished:
        command = input()
        result = game.execute(command)
        print(result)
        print("-")
        finished = result == "Congrats. You're out"
    print("-")


if __name__ == "__main__":
    sys.exit(main())

```

Con todo, esto funciona lo bastante bien como para que el juego sea jugable. Ahora mismo es aburrido porque basta con hacer `go north` para salir de la mazmorra. Pero la mecánica del juego está en su sitio. De nuevo, el software ya puede estar en manos de sus usuarias.

Pero desde el punto de vista del diseño, esta lógica no debería estar ahí. El _entry point_ se tiene que limitar a montar la aplicación y lanzarla. La mejor opción es moverla a un objeto que represente la aplicación.

Esto nos permite varias cosas:

* Poner bajo test la aplicación completa
* Inyectarle distintas dependencias dependiendo de nuestro entry point (consola, test, etc)
* Configurarla según el entorno donde se ejecuta
* Refactorizar fácilmente a un mejor diseño

Así que, en vez de eso, introducimos la clase `Application`, copiando el código que estaba en el _entry point_ y haciendo luego los cambios. Quedaría así:

```python
from dungeon.game import Game


class Application:
    def run(self):
        print("Welcome to the Dungeon")
        print("-")
        game = Game()
        game.start()
        print(game.execute("look around"))
        print("-")
        print(game.execute("go south"))
        print("-")
        print(game.execute("look around"))
        print("-")
        print(game.execute("go north"))
        print("-")


```

Y así de pequeñito queda el _entry point_:

```python
import sys

from dungeon.application import Application


def main(args=None):
    if args is None:
        args = sys.argv[1:]

    application = Application()
    application.run()


if __name__ == "__main__":
    sys.exit(main())

```

Ahora es cuando podríamos introducir la funcionalidad del input. En este momento lo hacemos un poco a la brava, pues no tenemos tests todavía, pero nos podemos fiar de los tests manuales y hacer un refactor posterior a un diseño mejor.

```python
from dungeon.game import Game


class Application:
    def run(self):
        print("Welcome to the Dungeon")
        print("-")
        game = Game()
        game.start()
        finished = False
        while not finished:
            command = input()
            result = game.execute(command)
            print(result)
            print("-")
            finished = result == "Congrats. You're out"
        print("-")

```

Ahora ya podríamos entregar esta parte de la historia de usuario.

Y mientras vamos obteniendo _feedback_ de como funciona y qué defectos van apareciendo, podemos empezar a prepararnos para la próxima rebanada, que sería añadir un _prompt_ que indique a la jugadora que el sistema está disponible para recibir sus comandos.

Hacer esto es tan simple como añadir un parámetro al _input_. Pero, recuerda, no tenemos tests de la aplicación (aunque tenemos tests de Game). Y tenemos algunos problemas no resueltos en el diseño de la responsabilidad del Output. Nos conviene avanzar en el diseño para no tener problemas en el futuro.

Básicamente, lo que queremos es aislar las responsabilidades de la obtención del input de la usuaria, y las de mostrar el output. Queremos algo así como un `ObtainUserCommand` y un `ShowOutput`.

Así que vamos a empezar a crear un test de la aplicación.

```python
class TestApplication(TestCase):
    def test_should_show_title(self):
        show_output = ShowOutput()
        app = Application(show_output)

        app.run()

        self.assertIn(self, "Welcome to the Dungeon", show_output.contents())
```

En este caso, vamos a tratar primero el output. Como se puede ver, vamos a incluir un nuevo objeto `ShowOutput`, que será responsable de mostrar la información. Inicialmente, será en la consola.

Esta es una implementación básica, suficiente para que el test se pueda ejecutar:

```python
class ShowOutput:
    def __init__(self):
        self._contents = ""

    def contents(self):
        return self._contents
```

El problema es que al ejecutar el test nos encontramos con que se detiene por el `input`, que espera una entrada por el teclado. Lo mejor es introducir un objeto (`ObtainUserCommand`) que lo abstraiga y, además, nos permita doblarlo para el test.

```python
class TestApplication(TestCase):
    def test_should_show_title(self):
        obtain_user_command = ObtainUserCommand()
        show_output = ShowOutput()
        app = Application(obtain_user_command, show_output)

        app.run()

        self.assertIn(self, "Welcome to the Dungeon", show_output.contents())

```


De hecho, de momento voy a introducir uno que me asegure no solo que se pasa un valor, sino que se puede terminar el juego.

```python
class ObtainUserCommand:
    def command(self):
        return "go north"
```

Y así quedan las modificaciones de Application para que el test pueda correr:

```python
class Application:
    def __init__(self, obtain_user_command, show_output):
        self._obtain_user_command = obtain_user_command
        self._show_output = show_output

    def run(self):
        print("Welcome to the Dungeon")
        print("-")
        game = Game()
        game.start()
        finished = False
        while not finished:
            command = self._obtain_user_command.command()
            result = game.execute(command)
            print(result)
            print("-")
            finished = result == "Congrats. You're out"
        print("-")
```

El test ya se ejecuta, pero falla. Nos hace falta asegurarnos de que al menos el mensaje de bienvenida es generado con `ShowOutput`.
